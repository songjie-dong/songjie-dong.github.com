<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[All Things Coding]]></title>
  <link href="http://songjie-dong.github.com/atom.xml" rel="self"/>
  <link href="http://songjie-dong.github.com/"/>
  <updated>2013-07-08T17:54:32+08:00</updated>
  <id>http://songjie-dong.github.com/</id>
  <author>
    <name><![CDATA[Songjie Dong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[30之后的志向]]></title>
    <link href="http://songjie-dong.github.com/blog/2013/07/08/30zhi-hou-de-zhi-xiang/"/>
    <updated>2013-07-08T15:46:00+08:00</updated>
    <id>http://songjie-dong.github.com/blog/2013/07/08/30zhi-hou-de-zhi-xiang</id>
    <content type="html"><![CDATA[<h2>而立</h2>

<p>30,女儿出世(感谢老天她并不黑),家庭生活的经济负担逐渐减小,有房无车(还不想买),话说未来已经毫无压力,但我害怕这种感觉.</p>

<p>本人天生喜欢体谅别人,当然体谅的前提是你会站在对方的角度思考问题,其实这本不是一个缺点,但是当你意识到父辈的各种痛苦,站在它们的角度去想到各种无奈,压力,迷茫,无知的时候,我终于意识我必须解决这个问题,我必须让我的家人不再痛苦,于是我奋斗到30岁,我意识到我基本解决了这个问题,除了类似个性不合这种NP问题以外.但突然我又意识到,我的人生的最好的时光不像有些人,我是背负了很沉重的包袱,我一直没有按自己的想法而活着,虽然我不断的再YY我的理想来安慰自己.</p>

<p>从13年1月进入天猫,重回阿里系,很大程度上这个决定由于我的女儿,因为我意识到一个稳定的大型公司仍然是我必须的,为什么不考虑创业:放眼望去,国内互联网一派虚假的繁荣昌盛,几个寡头仍然霸权主义严重,大部分所谓创业公司与我本人创业价值观严重不符,同时我也绕不过体制对我的约束,当然我也没在&#8221;异类&#8221;的范畴内,于是乎回到一个逐步打破体制格局的,极有前途的大公司成为了一个必然的选择.</p>

<p>我非常&#8221;理性&#8221;的选择了回归,很多人问是不是回来就升了一级,我只好无奈的回答,并没有,我走与回,无非还是按我人生前30年的思维惯性使然,跟某些所谓出去做几年再跳回来的世俗想法完全不搭,也许看起来很像是.</p>

<p>走,为什么走,为了走,我付出了很多,但是我同样得到一段宝贵的时间去梳理自己的知识结构,把支离破碎的知识连接起来,把这几年赶的路回顾一遍,现在看来,我觉得收获很大,停下来思考,放弃一份稳定的收入是需要&#8221;傻气&#8221;的.</p>

<p>为什么回来,刚刚已经回答过,现在我再思考的问题是:我这样做对我30之后有好处吗?</p>

<h2>30之后的志向</h2>

<p>由于孩子的出世,我一直在读一些教育方面的书籍,目前还是以婴幼儿的为主,再读完几篇著作后,结合我对自己/身边的人成长的复盘(客观的观察自己,得益于克里希那穆提这位智者的书),我意识到所谓对于孩子的教育,只需要做好一件事:把自己做好!,因为人类的很多性格,习惯,逻辑思维方式的形成部分源于本性,部分源于模仿,而家人则成为了主要的模仿对象.本性很大程度上让我还是个好孩子,父亲一直在跟我讲德国怎么怎么好,于是让我对于严谨,长期的积累,不短视(当然他没提到德国人的守时,于是我没学到)这些东西天然的接受和有好感.(于是我看问题总是看长期,如果目标短视则一概鄙视,就像现在的国内,先富起来的人对利益的嗜血绝不亚于资本主义原始积累时期)</p>

<p>有了这个判断,我认为:我的下半辈子做好我自己就可以,无需说我的下半辈子就是为了孩子,因为我做好我自己,我就能教育她,这无需我付出太多额外的工作,言传身教即可,而一旦我用超出我自己的范畴的想法去教育孩子,无异于是毒害了她,每个人生下来都有自己最好的活法,我的目标是让她慢慢找到自己的活法,而不是灌输我的活法,也许只要让她对我的活法有小小的崇拜和深入的了解即可.</p>

<p>总结前30年,是为自己的浑浑噩噩,包袱而一路活过来的,虽然做的还不错,但30之后我要做自己,做自己才能给家人更好的幸福.</p>

<p>30之后的志向:&#8221;改变&#8221;,改变什么?这个世界有太多的东西可以去改变,但是要建立在一个普世的原则基础上的,我认为现有的环境对我而言需要付出太多的个性改造才能发挥个人的作用,但这对于一个人来说未免过于残酷(该死的德国情节),于是我决定暂时放弃所谓的精忠报国的思想,好好研究下一步如何能自由的探究本人对于好奇心的欲望,对于&#8221;改变&#8221;的执着,找到自己能为之真正付出的事业,国家终有可以回报的一天,但不能以牺牲自己为代价,这是以什么为本位的问题,也是千百年烙在我们心灵的问题:国破家亡/士亡则国亡.</p>

<p>一切都想清楚了,后续一年半的计划:
-  大公司始终不是目标,还有一年半,善始善终,但不会付出太多精力,找个舒服的姿势工作着先,万一形势不对则不计报酬上的损失.
-  按自己的热情来学习技术/语言
-  好好锻炼身体
-  为下一阶段的学习计划储备好必要的资源
-  花些时间与家人共处</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[破局者]]></title>
    <link href="http://songjie-dong.github.com/blog/2013/06/27/po-ju-zhe/"/>
    <updated>2013-06-27T21:30:00+08:00</updated>
    <id>http://songjie-dong.github.com/blog/2013/06/27/po-ju-zhe</id>
    <content type="html"><![CDATA[<h2>对国足惨案的复盘</h2>

<p>国足1:5负于泰国的比赛,看完后冒出一个问题:在人民币由8时代到6时代的这段时间,国足居然&#8221;国进足退&#8221;,什么力量这么强大,这么多年,中国足球不可谓投钱不多,不可谓没有年轻俊才(参考克劳琛带队的05世青赛),当年的那拨人被寄予厚望,最后也泯然众人了.</p>

<p>砸了这么多钱,废了这么多年轻人,中国足球依然无法提升,反而极大的倒退,以前还记得身作国旗,如今消极的忘了自己代表谁,这还是中华民族所谓的民族气节吗?什么让这么多人心血付之东流,如此大的阻力来自何方?体制,中国的一切问题最后都指向了体制,而现有的体制已经由我们党国的精英们把持着,想要进入体制内太难,想要跟体制共舞太难,想要无视体制,你发现体制已经跟日常饮用水质量挂上勾了,逃脱体制吧,现在海外已经不是需要勤杂工的年代了(非洲除外,如果你想进入另一个荒诞体制也是可行的)</p>

<h2>破局者</h2>

<p>sky,电竞界响当当的名字,上周花了点时间看了sky的自传,看看一个sky如何将正能量带向当时饱受诟病的中国电竞圈:长期不被父母所承认,长期昼夜颠倒,长期吃一种简单的食物(很庆幸当时方便面算贵的,否则sky应该在天堂了),在与世俗的长期对抗后,终于靠着自己的简单,朴素的执着和热情(自传里没有任何华丽的辞藻和对自己的歌功颂德)成为了中国电竞第一人,成为了世界冠军,给家里买了房,车,年收入在百万左右.</p>

<p>在中国成为sky何其困难,复盘sky的成功可谓是一路危机四伏,压力巨大,靠着过人的执着,sky成功了,这里我估计称之为&#8221;破局者&#8221;,破局者:能打破体制的困境,走上台面,甚至能跟体制内的人叫板,目标是建立新的体制,打破旧的观念.sky已经离开的war3,他找到了新的理想,为中国电竞尽自己的一份力,希望他能带领中国的电子竞技真正成为国家承认的第xx项体育运动,成为民众心中健康的运动,这个理想值得也需要付出几代人的努力.</p>

<p>互联网大佬,说起老马的菜鸟网络,支付宝的余额宝,阿里金融的小额贷款,淘宝,腾讯的微信,你会发现一个特点:这些产品都动了体制内大佬们的蛋糕,甚至是让它们有了危机感,互联网时代的到来逐步产生了另外的一层涵义:它以一种民众认同的方式打破体制的束缚,重建我们的社会基础和体系.而这些事体制内的大佬们不是没有意见,但是9巨头已然意识到大佬们养尊处优的太久,且不听从管教,当面一套背后一套,眼高手低,已经无法完成党国赋予的21世纪国家发展的任务,而放眼望去,这些互联网大佬们深得民意,眼高且实干能力强,最重要的是也听话,于是我们的菜鸟网络名正言顺,我们私下将支付宝独立出去名正言顺,yahoo可以告,但它们告的不是阿里,是国家安全局.</p>

<p>这个国家需要破局者将巨大的体制惯性冲破,让民众看到希望,星星之火可以燎原!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA['计算密集型操作优化探究']]></title>
    <link href="http://songjie-dong.github.com/blog/2013/04/17/ji-suan-mi-ji-xing-cao-zuo-you-hua-tan-jiu/"/>
    <updated>2013-04-17T23:32:00+08:00</updated>
    <id>http://songjie-dong.github.com/blog/2013/04/17/ji-suan-mi-ji-xing-cao-zuo-you-hua-tan-jiu</id>
    <content type="html"><![CDATA[<p>半年前开始有个蠢想法,对java里面的代数表达式计算的可优化做研究,看看能否有一些成果可以提炼出来,现在看来这个想法有点难度太大&#8230;.大到几乎没有价值,所以要投身开源还是从研究开源开始,表异想天开造轮子了.</p>

<p>且不提为什么有这种想法吧,起初我想研究一些在代码实现过程中能优化的程度,但看过龙书,特别是鲸书后,基本没了想法.首先列一些我想得到的优化可能:
- 公共子表达式消除
- 乘与加转换
- 由于我们coding需要考虑可读性,但对于复杂公式,我们不会考虑自己来消除,否则会带来可读性问题
- 重复计算时,部分变量的全局缓存</p>

<p>没想法的原因如下:
java 本身支持对公共子表达式的消除,经过测试发现,编译时会做非常简单而且显而易见的消除优化,jit则会根据平台特性来做针对性优化,而且只有jit能做针对性的优化.以上的优化可能我们逐一分析,公共子表达式消除的问题,如果你将一些子表达式提取成变量,可能需要考虑寄存器分配(Register allocation)问题,变量增加可能会导致溢出(spilling),于是变量需要在RAM来分配和访问.考虑到计算成本远远小于RAM访问成本,所以子表达式消除与cpu实现相关,有些情况可能会做向前替换,消除变量,避免不必要的溢出(spilling).通常建议在LIR做子表达式消除,就是因为子表达式消除并不总是对的.</p>

<p>乘法的性能如果已经足够好了,还要优化成加法吗?</p>

<p>变量分配到register,于是对于java GC本身压力不大,全局变量缓存甚至是反作用.</p>

<p>低级别优化,特殊架构下的特殊指令优化.</p>

<p>java code 怎么做都可能是错的&#8230;所以还是洗洗睡吧.</p>

<p>openjdk7,我没找到明确的code&#8230;.但发现hsdis已经集成到7里面了,反汇编应该可以用来分析JVM内部对于表达式消除的优化处理,这块除了特别关注计算性能和开销才会考虑研究jit优化的结果是否符合要求,但通常也不会过于关注表达式消除,反而是用了表达式消除带来的溢出才可能是个问题.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Big List Of 20 Common Bottlenecks]]></title>
    <link href="http://songjie-dong.github.com/blog/2013/04/01/big-list-of-20-common-bottlenecks/"/>
    <updated>2013-04-01T20:04:00+08:00</updated>
    <id>http://songjie-dong.github.com/blog/2013/04/01/big-list-of-20-common-bottlenecks</id>
    <content type="html"><![CDATA[<h2>tips</h2>

<p>翻译水平有待提高.部分内容添加了个人的理解.</p>

<h2>前言</h2>

<p>在<a href="http://highscalability.com/blog/2012/2/27/zen-and-the-art-of-scaling-a-koan-and-epigram-approach.html">Zen And The Art Of Scaling - A Koan And Epigram Approach</a>这篇文章中,Russell Sullivan提出了一个有趣的猜想:存在20个经典的瓶颈.这听起来疑似那个&#8221;只有20个基本的故事情节&#8221;的想法.这完全取决于你看瓶颈的视角,也许这个想法是对的,但实践过程中我们都知道瓶颈来自于无穷的&#8221;味道&#8221;,所有的酸和灰.</p>

<ul>
<li>chunkify这个单词翻译的太纠结了,没明白啥意思,先意会一下吧.</li>
<li>酸我能理解是个味道,灰是啥&#8230;&#8230;.</li>
<li>sullivan在分布式数据库方面很牛,Alchemy Database没怎么研究过呢还,但是卖点是混合型数据库,貌似是redis+server side script实现,参考<a href="http://highscalability.com/blog/2012/2/27/zen-and-the-art-of-scaling-a-koan-and-epigram-approach.html">zen and the art of scaling</a></li>
</ul>


<p>有一天<a href="http://jsoftbiz.wordpress.com/">Aurelien</a>发送了他的瓶颈列表给我, 我们cc给了Russell,他给了我他的列表,我也有一份列表,于是产生了一份石头汤</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Stone_Soup">石头汤</a></li>
</ul>


<p>Russell说这是他的&#8221;我希望在我年轻的时候我知道&#8221;列表,我想应该用一种不断充实的方式来看待它:拥有更多的经验,处理更多不同类型的项目,会有更多的教训你能够添加到这份列表中.当你读到这份列表,并且制作自己的列表时,你正在通过多年积累的经验和一点点挫折而不断变强,并且其中每一条都有一个故事值得grokking.</p>

<ul>
<li>grokking 实在是无法用一个词汇来描述&#8230;.</li>
</ul>


<h2>瓶颈的个人理解</h2>

<h3>Database:</h3>

<ul>
<li><p>Working size exceeds available RAM</p>

<p>工作内存超过了系统可用的内存,可能会大量出现malloc失败或者触发swap区不断的换入换出,或者触发内存碎片整理这种成本较高的动作.对于数据库来说,性能应该会下降的很快,这个不用说,内存总是比硬盘快.基本上离挂不远.</p></li>
<li><p>Long &amp; short running queries</p>

<p>耗时较长的查询会占用系统资源一段较长的时间无法释放,会带来性能的波动.通常来说,业务上对于数据查询的场景是属于OLTP or OLAP需要分析清楚先,并以此作为技术选型的评估因素之一.</p></li>
<li><p>Write-write conflicts</p>

<p>大量的并发写冲突问题,此问题我分为两种情况:对系统整体的影响,热点的问题.</p>

<ul>
<li><p>整体的影响如何解决?</p>

<p>Sharding strategies often involve two techniques: partitioning and replication. With partitioning, the data is divided into small chunks and stored across many computers. Each of these chunks is small enough that the computer that stores it can efficiently manipulate and query the data. With the other technique of replication, multiple copies of the data are stored across several machines. Since each copy runs on its own machine and can respond to queries, the system can efficiently respond to tons of queries for the same data by adding more copies. Replication also makes the system resilient to failure because if any one copy is broken or corrupt, the system can use another copy for the same task.</p></li>
<li><p>热点</p>

<p>scale up性能,比如数据库热点数据,可以单独拿出来提供服务.热点操作的针对性优化,比如对于计数器场景,cpu做必要的优化,写可以用thread local or array + padding.</p></li>
</ul>
</li>
<li><p>Large joins taking up memory</p>

<p>尽量避免两张大表join,将sql拆开为两次简单查询是一种解救办法,但可能会出现too much short running queries问题,需要结合性能数据分析权衡ROI
.</p></li>
</ul>


<h3>Virtualisation:</h3>

<p>这个领域&#8230;比较小白啊,先放着</p>

<ul>
<li><p>Sharing a HDD, disk seek death</p></li>
<li><p>Network I/O fluctuations in the cloud</p></li>
</ul>


<h3>Programming:</h3>

<ul>
<li><p>Threads: deadlocks, heavyweight as compared to events, debugging, non-linear scalability, etc&#8230;</p></li>
<li><p>Event driven programming: callback complexity, how-to-store-state-in-function-calls, etc&#8230;</p>

<p>callback的复杂性:callback有两种,block callback&amp;async callback,通常这种模式提供给模块使用者,来扩展已有功能的一种方式.我个人感觉上callback对于一些严谨的模块维护者来说,侵入性较强,难以控制.模块使用者会比较容易写出破坏接口语义的实现,特别是对于async的接口.</p>

<p>store state&#8230;不知所云</p></li>
<li><p>Lack of profiling, lack of tracing, lack of logging</p>

<p>使用成熟的工具,提供profiling是必须的.
跟踪&#8212;分布式环境跟踪是个问题,事件需要统一收集和分析,etc..kafka
logging &#8211;例子很多了.不用一台台scp download日志,否则会疯了.</p></li>
<li><p>One piece can&#8217;t scale, SPOF, non horizontally scalable, etc&#8230;</p>

<p>可扩展性是架构设计需要解决的基本问题,但也是非常复杂的问题,无状态,分区可扩展性.</p></li>
<li><p>Stateful apps</p>

<p>有状态就可能涉及到状态的持久化问题,同时状态的可靠性持久化需要一些复杂的的机制来保证:write ahead logging, quorum, replication,raid,paxos etc&#8230;</p></li>
<li><p>Bad design : The developers create an app which runs fine on their computer. The app goes into production, and runs fine, with a couple of users. Months/Years later, the application can&#8217;t run with thousands of users and needs to be totally re  architectured and rewritten.</p>

<p>这事天天发生</p></li>
<li><p>Algorithm complexity</p>

<p>复杂意味着维护性问题,可扩展性问题,调优问题.</p></li>
<li><p>Dependent services like DNS lookups and whatever else you may block on.</p>

<p>前端性能优化&#8230;域名可以拆分,但不能过多.</p></li>
<li><p>Stack space</p>

<p>栈还是有开销的&#8230;.特别是对于线程创建后的栈固定分配时,线程创建的开销还是不可忽视的,虽然有所谓的copy on write优化&#8230;
无其他想法了,除了line优化降低栈深度.</p></li>
</ul>


<p>以后在补充吧.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爷爷的两三事]]></title>
    <link href="http://songjie-dong.github.com/blog/2013/01/28/ye-ye-de-liang-san-shi/"/>
    <updated>2013-01-28T21:40:00+08:00</updated>
    <id>http://songjie-dong.github.com/blog/2013/01/28/ye-ye-de-liang-san-shi</id>
    <content type="html"><![CDATA[<p>两周前到西湖苏堤去看夕阳,顺便游览了一番,游玩时想到爷爷,他是浙江人,也因为他以前在世时的两三事,途中偶尔会天真的幻想爷爷还在世我们讨论的话题会是&#8230;..</p>

<p>说起爷爷,小时候经常翻阅爷爷的藏书,都是繁体书,印象中较为深刻的是爷爷买的书都会在第一页写上江贤端购于xx地,年月日的字样,本本如此,如今这个遍地物质精神快餐的时代,谁还会有如此雅兴.至于哪些书已经完全记不得,只是在爷爷去世时,我保留了一本繁体版的史记,纸质早已发黄,此书我只看过与刺客列传相关的内容,惭愧,惭愧.</p>

<p>爷爷让我印象深刻的地方还有他70岁了还在学习英语,而且方式就是听广播,那时我刚刚上初中开始学习英语,印象中爷爷最喜欢与我讨论英语知识,有时教的不对还会特意走到我家来纠正之前的错误,怪我少不更事,如今想来,爷爷这样的人在现代社会实在是太少了,我们这代80后到了70岁坚持学习的人能有多少?</p>

<p>爷爷还会很有雅兴的养养金鱼,种种盆景啥的,盆景不大,白天有空的时候我偶尔会跟着爷爷在阳台发呆,虽不太懂得欣赏盆景,但很好奇这种植物为啥值得天天看,还得修剪.</p>

<p>至于爷爷对我的偏爱,爷爷毫不掩饰,周末都会带我到公园去玩,蹦床一玩就是一个下午,一个6,70岁的老人就这么陪着我度过了无数个这样的下午,有一次玩到没钱了,爷爷还去找公园里不认识的人借钱,哎,被我逼到这份上了.</p>

<p>大学时去杭州玩,特意要求去浙大拍了张照,我不是喜欢拍照的人,但是我想去看看爷爷读过书的地方,从而能在内心根据这些积攒下来的记忆拼凑爷爷在我心中的印象.我觉得爷爷是那个时代的知识分子,毕竟那时候能读大学的人并不多,何况是浙大.</p>

<p>爷爷走的很辛苦,多年的支气管炎,一到武汉的冬天就必须得住院,那时家里都不富裕,最后爷爷也不愿意去医院了,就在那年走了,爷爷其实有个妹妹,家里还算富足,想来爷爷也是做好了打算,并无留恋之意才执意不去医院的.</p>

<p>哎,如果能再和您说上一次话,我想我会少走很多弯路,如果能再吃上您炒的油盐饭,鱼香肉丝,风干羊腿火锅,我一定会感动的痛哭流涕,如果能再与您讨论英语学习,我想我也不会痛恨这门课程,如果您还在,或许我们可以一起痛骂世道不古,把老一代知识分子的精神全都丢了的时代,又或许与您一起畅游西湖,回忆您的往事,我想一定会很精彩.</p>

<p>一直都是眼含泪水的写到这里,因为很遗憾我当时的少不更事,碌碌无为.遗憾是生命中最残忍的事情,希望您能在天上好好的看着我,看着我的成长,并非是我现在有多么好,而是我会尽一生接近您想要的人间正道.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Is parallel programming hard? - 2 ]]></title>
    <link href="http://songjie-dong.github.com/blog/2012/11/15/is-parallel-programming-hard-2/"/>
    <updated>2012-11-15T14:39:00+08:00</updated>
    <id>http://songjie-dong.github.com/blog/2012/11/15/is-parallel-programming-hard-2</id>
    <content type="html"><![CDATA[<h2>问题</h2>

<p>CAS是否是绝对的灵丹妙药呢?</p>

<h2>测试</h2>

<p>根据并发编程实践中的结论,极端的竞争条件下,Lock表现出比CAS更好的性能,在中等的竞争条件下,CAS明显胜出.</p>

<h2>Is parallel programming hard 书中关于CAS过程的分析</h2>

<p>对于一次CAS操作,如果是最好的情况:当前处理的core的l1 cache line 命中,则直接操作,如果miss,则会通过Interconnect通讯其他core,寻找CAS操作的数据,core间传输数据的开销不低,在4-CPU 1.8GHz AMD Opteron 844 System上,整个miss的CAS操作需要500个clock cycle.而命中的情况下只需要63个clock cycle.</p>

<p>另外java里实现的CAS都有一定数量的spin操作,如果大量的竞争失败,对于CPU来说则是做了很多无用功.</p>

<h2>结论</h2>

<p>吞吐量的测试结果是在高并发的情况下:CAS的miss开销+CPU无用功 > Lock的开销(context switch, cache miss).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分支预测的迷思]]></title>
    <link href="http://songjie-dong.github.com/blog/2012/11/08/fen-zhi-yu-ce-de-xian-jing/"/>
    <updated>2012-11-08T18:29:00+08:00</updated>
    <id>http://songjie-dong.github.com/blog/2012/11/08/fen-zhi-yu-ce-de-xian-jing</id>
    <content type="html"><![CDATA[<h2>What</h2>

<p>首先,看看什么是分支预测,这个技术的出现是由于CPU技术的进步,现代CPU都采用了流水线结构,而且流水线越深(按深入理解计算机提到的是15),利用率越高,但流水线引入了一个问题,就是需要预先将指令取出并reordering再放入流水线,而程序中的分支则导致无法预取指令,必须等到evaluate条件指令之后才能确定,这会导致流水线无法充分利用.本文介绍一些基本的关于分支预测的概念和实现方式,具体的概念和资料请参考<a href="http://zh.wikipedia.org/zh/%E5%88%86%E6%94%AF%E9%A0%90%E6%B8%AC%E5%99%A8">分支预测器</a></p>

<p>intel官方数据分支预测器能保证在工业测试中达到94%+的成功率,但这就像intel官方宣布的MIPS一样不靠谱,实际的情况有时会不如人意,分支预测成功率低会导致流水线需要重新取指并reordering,大约开销在20 clock cycle以内(数据各有差异,但我没看到20以上的),通常在5%以上就值得关注,10%以上就难以忍受了.</p>

<h2>分支预测的主流技术</h2>

<p>分支预测需要做两件事:
1. 预测branch可能的方向
2. 从BTB中找到对应的PC地址,取指并reording(实际情况步骤会更多)</p>

<p>BTB可以理解为一个hashmap,里面保存了某branch对应方向对应的需执行指令地址,BTB大小有限.</p>

<p>预测算法:</p>

<ol>
<li><p>饱和计数
使用两个bit保存具备4种状态的状态机,状态机具有强不选择,弱不选择,弱选择,强选择,说简单点就是只有两次选择到同样的分支,状态机才会选择改变分支方向,早期的奔腾系列使用了这种方法,测试结果达到93.5%的准确率,但我们很容易就可以发现它的弱点.</p></li>
<li><p>两级自适应预测器
记录n次branch history的结果作为一个当前模式,同时存在一个pattern history table,这里面记录了n个长度模式和n个对应的饱和计数器.简而言之这是一个基于模式识别,具备很强的预测模式能力的预测器.
通常来说,每个分支都需要一个独立的pattern history table,称之为本地分支预测,但考虑到对于m条分支预测指令,n次长度的历史模式来说,需要消耗的内存极大,所以有了全局分支预测,它提供了共享的pattern history table,好处是如果多条分支预测相同,则可以共享预测的效果,但如果多条分支只在部分情况下共享分支结果则适得其反.本地分支预测达到了97.1%的准确率,全局分支预测则为96.6%,当然我们需要费点力气才能发现它们的弱点.</p></li>
<li><p>静态预测
总是用一种方向来预测.编译器可以提供hint给cpu,适用类似if (xxx == null)的场景.</p></li>
<li><p>循环分支预测
对于现代cpu都会对loop的跳出条件做特殊优化,他会记录条件值和当前循环次数,当达到退出条件时直接预测跳出,这个计数值不会无限大,intel官方数据是16,也有说64的.</p></li>
<li><p>融合分支预测
本地和全局预测组合.</p></li>
</ol>


<h2>案例&amp;分析</h2>

<p>以下列举一些在intel core 2上的测试用例,用例只涉及到对某些具体模式的分支情况做讨论,不涉及实际应用中的复杂模式以及资源竞争的影响,同时结论也不一定适用于其他类型的CPU,这么做的原因在于:对分支预测来说,难以给出统一的结论性原则,但我们需要考虑如何识别潜在分支预测失败因子以及更重要的避免不必要的预测,或者消除它们.</p>

<p>数据采集使用perf这个linux下的系统性能调优工具,我们用该工具来获取分支预测数据,<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-perf1/index.html">介绍</a>,vtune是intel官方的分析工具,有空可以装来玩玩.</p>

<p>单表达式随机化:</p>

<figure class='code'><figcaption><span>single condition  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>  <span class="n">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">(</span><span class="n">seed</span><span class="o">);</span>
</span><span class='line'>  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">//do something</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">//do something</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是一个最为简单,貌似看起来也很具有破坏性的例子,但是intel是强大的,根据一些分析,intel使用了多种预测器的组合,同时具备很强的自适应性,so结果很惊人:
branch-misses 2%-3% of all branches</p>

<p>结果基本在3%以内,也就是97%的准确率,由于intel对于分支预测并未公开过细节,所以不做过多讨论.</p>

<p>增加一个判断条件:</p>

<figure class='code'><figcaption><span>multi-condition  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>  <span class="n">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">(</span><span class="n">seed</span><span class="o">);</span>
</span><span class='line'>  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">//do something</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">//do something</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>结果:
branch-misses 8%-12% of all branches</p>

<p>注意我的这个case,if判断内两个表达式都完全随机,两者毫无关联,此时miss率上升到8%-9%,随着我不断在if中加入随机性的表达式,miss率逐步提到12%左右.</p>

<p>失败模式:单if多随机表达式的杀伤力很强,消除方法可以考虑合并二者,比如上面的例子可以将表达式相加判断是否大于1,复杂情况考虑各种淫荡的位操作.</p>

<p>还有一种方式适用于表达式与loop无关的场景,可以将if外提,从而消除分支预测(编译优化).预测即使miss率很低也会消耗很多资源,而影响到其他的branch.</p>

<p>多条件分支:</p>

<figure class='code'><figcaption><span>if-else-condition  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>  <span class="n">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">(</span><span class="n">seed</span><span class="o">);</span>
</span><span class='line'>  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">8</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">//do something</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">8</span><span class="o">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">//do something    ... next else if </span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">//do something</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种场景同样会带来5-8%左右的miss率,这个case中参数完全随机,现实中不太会出现这样的情况,这种模式在部分情况下可以用mapping的方式去消除.</p>

<p>循环退出条件的优化-循环展开:</p>

<figure class='code'><figcaption><span>before loop-unrolling  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">65</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>after loop-unrolling  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">65</span><span class="o">;</span> <span class="n">j</span><span class="o">+=</span><span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
</span><span class='line'>        <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>将循环表达式中innerloop的循环次数降到64(需要考虑CPU的实现)以下,则可以使用CPU的循环分支预测器.
这种方式如果两层循环,且外循环很大的情况下容易出现问题.展开的坏处是代码量增加,好处是分支预测效率高,占用资源少,同时指令可以充分利用流水线和并行.由于在我的机器上对于这种场景难以复现,我就没提供测试数据对比.但loop-unrolling是分支预测典型的优化方式之一.</p>

<p>最后这个场景代码逻辑是在一个大的int二维数组中按随机顺序造了一些测试的奇偶数序列,然后在循环的条件分支中判断奇偶数,一共有10个case,它们的长度分别是2,2+1,4,4+1,8,8+1,16,16+1,32,32+1,另外测试条件是多表达式.</p>

<figure class='code'><figcaption><span>branch predictor test  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
</span><span class='line'>      <span class="kt">int</span><span class="o">[][]</span> <span class="n">randoms</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[][]</span> <span class="o">{</span>
</span><span class='line'>              <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span>
</span><span class='line'>              <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span>
</span><span class='line'>              <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span>
</span><span class='line'>              <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span>
</span><span class='line'>              <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span>
</span><span class='line'>              <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span>
</span><span class='line'>              <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span>
</span><span class='line'>              <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span>
</span><span class='line'>              <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span>
</span><span class='line'>              <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span>
</span><span class='line'>      <span class="o">};</span>
</span><span class='line'>      
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;branch predictor sequence length:&quot;</span> <span class="o">+</span> <span class="n">randoms</span><span class="o">[</span><span class="n">y</span><span class="o">].</span><span class="na">length</span><span class="o">);</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>              <span class="k">if</span> <span class="o">(</span><span class="n">randoms</span><span class="o">[</span><span class="n">y</span><span class="o">][</span><span class="n">j</span><span class="o">%</span><span class="n">randoms</span><span class="o">[</span><span class="n">y</span><span class="o">].</span><span class="na">length</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">randoms</span><span class="o">[</span><span class="n">y</span><span class="o">][</span><span class="n">i</span><span class="o">%</span><span class="n">randoms</span><span class="o">[</span><span class="n">y</span><span class="o">].</span><span class="na">length</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                  <span class="n">x</span> <span class="o">=</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
</span><span class='line'>              <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>                  <span class="n">x</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
</span><span class='line'>              <span class="o">}</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>测试脚本:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>  <span class="k">for </span>i in <span class="o">{</span>0..9<span class="o">}</span>
</span><span class='line'>  <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="nb">echo</span> -e <span class="s2">&quot;test case:$i\n&quot;</span>
</span><span class='line'>    perf stat java GGG <span class="nv">$i</span>
</span><span class='line'>  <span class="k">done</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>result </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>test case:0
</span><span class='line'>
</span><span class='line'>branch predictor sequence length:2
</span><span class='line'>99999
</span><span class='line'>
</span><span class='line'> Performance counter stats for 'java GGG 0':
</span><span class='line'>
</span><span class='line'>        435.919199 task-clock                #    1.028 CPUs utilized          
</span><span class='line'>               135 context-switches          #    0.000 M/sec                  
</span><span class='line'>                37 CPU-migrations            #    0.000 M/sec                  
</span><span class='line'>             4,203 page-faults               #    0.010 M/sec                  
</span><span class='line'>     1,278,164,688 cycles                    #    2.932 GHz                     [51.00%]
</span><span class='line'>   &lt;not supported> stalled-cycles-frontend 
</span><span class='line'>   &lt;not supported> stalled-cycles-backend  
</span><span class='line'>     1,649,473,158 instructions              #    1.29  insns per cycle         [76.19%]
</span><span class='line'>       454,492,126 branches                  # 1042.606 M/sec                   [74.86%]
</span><span class='line'>         1,593,299 branch-misses             #    0.35% of all branches         [74.27%]
</span><span class='line'>
</span><span class='line'>       0.424036750 seconds time elapsed
</span><span class='line'>
</span><span class='line'>test case:1
</span><span class='line'>
</span><span class='line'>branch predictor sequence length:3
</span><span class='line'>100000
</span><span class='line'>
</span><span class='line'> Performance counter stats for 'java GGG 1':
</span><span class='line'>
</span><span class='line'>        440.982464 task-clock                #    1.017 CPUs utilized          
</span><span class='line'>               134 context-switches          #    0.000 M/sec                  
</span><span class='line'>                 7 CPU-migrations            #    0.000 M/sec                  
</span><span class='line'>             4,202 page-faults               #    0.010 M/sec                  
</span><span class='line'>     1,313,300,847 cycles                    #    2.978 GHz                     [48.14%]
</span><span class='line'>   &lt;not supported> stalled-cycles-frontend 
</span><span class='line'>   &lt;not supported> stalled-cycles-backend  
</span><span class='line'>     1,691,221,085 instructions              #    1.29  insns per cycle         [74.32%]
</span><span class='line'>       464,577,389 branches                  # 1053.505 M/sec                   [76.70%]
</span><span class='line'>         1,860,782 branch-misses             #    0.40% of all branches         [75.40%]
</span><span class='line'>
</span><span class='line'>       0.433542282 seconds time elapsed
</span><span class='line'>
</span><span class='line'>test case:2
</span><span class='line'>
</span><span class='line'>branch predictor sequence length:4
</span><span class='line'>100000
</span><span class='line'>
</span><span class='line'> Performance counter stats for 'java GGG 2':
</span><span class='line'>
</span><span class='line'>        404.754545 task-clock                #    0.998 CPUs utilized          
</span><span class='line'>               134 context-switches          #    0.000 M/sec                  
</span><span class='line'>                 0 CPU-migrations            #    0.000 M/sec                  
</span><span class='line'>             4,201 page-faults               #    0.010 M/sec                  
</span><span class='line'>     1,205,179,492 cycles                    #    2.978 GHz                     [49.49%]
</span><span class='line'>   &lt;not supported> stalled-cycles-frontend 
</span><span class='line'>   &lt;not supported> stalled-cycles-backend  
</span><span class='line'>     1,458,990,354 instructions              #    1.21  insns per cycle         [75.24%]
</span><span class='line'>       376,194,631 branches                  #  929.439 M/sec                   [75.31%]
</span><span class='line'>         1,333,624 branch-misses             #    0.35% of all branches         [75.46%]
</span><span class='line'>
</span><span class='line'>       0.405460356 seconds time elapsed
</span><span class='line'>
</span><span class='line'>test case:3
</span><span class='line'>
</span><span class='line'>branch predictor sequence length:5
</span><span class='line'>99999
</span><span class='line'>
</span><span class='line'> Performance counter stats for 'java GGG 3':
</span><span class='line'>
</span><span class='line'>        672.566849 task-clock                #    0.998 CPUs utilized          
</span><span class='line'>               169 context-switches          #    0.000 M/sec                  
</span><span class='line'>                 0 CPU-migrations            #    0.000 M/sec                  
</span><span class='line'>             4,202 page-faults               #    0.006 M/sec                  
</span><span class='line'>     2,008,298,057 cycles                    #    2.986 GHz                     [49.48%]
</span><span class='line'>   &lt;not supported> stalled-cycles-frontend 
</span><span class='line'>   &lt;not supported> stalled-cycles-backend  
</span><span class='line'>     1,525,468,338 instructions              #    0.76  insns per cycle         [75.04%]
</span><span class='line'>       407,631,191 branches                  #  606.083 M/sec                   [75.57%]
</span><span class='line'>        23,903,519 branch-misses             #    5.86% of all branches         [75.13%]
</span><span class='line'>
</span><span class='line'>       0.673644531 seconds time elapsed
</span><span class='line'>
</span><span class='line'>test case:4
</span><span class='line'>
</span><span class='line'>branch predictor sequence length:8
</span><span class='line'>100000
</span><span class='line'>
</span><span class='line'> Performance counter stats for 'java GGG 4':
</span><span class='line'>
</span><span class='line'>        405.341190 task-clock                #    0.998 CPUs utilized          
</span><span class='line'>               129 context-switches          #    0.000 M/sec                  
</span><span class='line'>                 0 CPU-migrations            #    0.000 M/sec                  
</span><span class='line'>             4,204 page-faults               #    0.010 M/sec                  
</span><span class='line'>     1,207,034,902 cycles                    #    2.978 GHz                     [47.61%]
</span><span class='line'>   &lt;not supported> stalled-cycles-frontend 
</span><span class='line'>   &lt;not supported> stalled-cycles-backend  
</span><span class='line'>     1,464,313,449 instructions              #    1.21  insns per cycle         [73.32%]
</span><span class='line'>       373,966,105 branches                  #  922.596 M/sec                   [76.32%]
</span><span class='line'>         1,419,666 branch-misses             #    0.38% of all branches         [76.29%]
</span><span class='line'>
</span><span class='line'>       0.406078318 seconds time elapsed
</span><span class='line'>
</span><span class='line'>test case:5
</span><span class='line'>
</span><span class='line'>branch predictor sequence length:9
</span><span class='line'>100000
</span><span class='line'>
</span><span class='line'> Performance counter stats for 'java GGG 5':
</span><span class='line'>
</span><span class='line'>        794.795883 task-clock                #    0.998 CPUs utilized          
</span><span class='line'>               190 context-switches          #    0.000 M/sec                  
</span><span class='line'>                 0 CPU-migrations            #    0.000 M/sec                  
</span><span class='line'>             4,203 page-faults               #    0.005 M/sec                  
</span><span class='line'>     2,373,644,196 cycles                    #    2.986 GHz                     [49.22%]
</span><span class='line'>   &lt;not supported> stalled-cycles-frontend 
</span><span class='line'>   &lt;not supported> stalled-cycles-backend  
</span><span class='line'>     1,516,162,160 instructions              #    0.64  insns per cycle         [74.37%]
</span><span class='line'>       402,595,975 branches                  #  506.540 M/sec                   [75.37%]
</span><span class='line'>        36,324,079 branch-misses             #    9.02% of all branches         [75.57%]
</span><span class='line'>
</span><span class='line'>       0.796235469 seconds time elapsed
</span><span class='line'>
</span><span class='line'>test case:6
</span><span class='line'>
</span><span class='line'>branch predictor sequence length:16
</span><span class='line'>99999
</span><span class='line'>
</span><span class='line'> Performance counter stats for 'java GGG 6':
</span><span class='line'>
</span><span class='line'>        408.163870 task-clock                #    0.998 CPUs utilized          
</span><span class='line'>               136 context-switches          #    0.000 M/sec                  
</span><span class='line'>                 0 CPU-migrations            #    0.000 M/sec                  
</span><span class='line'>             4,202 page-faults               #    0.010 M/sec                  
</span><span class='line'>     1,214,173,766 cycles                    #    2.975 GHz                     [49.83%]
</span><span class='line'>   &lt;not supported> stalled-cycles-frontend 
</span><span class='line'>   &lt;not supported> stalled-cycles-backend  
</span><span class='line'>     1,533,685,373 instructions              #    1.26  insns per cycle         [75.45%]
</span><span class='line'>       412,685,366 branches                  # 1011.078 M/sec                   [75.54%]
</span><span class='line'>         1,366,491 branch-misses             #    0.33% of all branches         [74.87%]
</span><span class='line'>
</span><span class='line'>       0.408941737 seconds time elapsed
</span><span class='line'>
</span><span class='line'>test case:7
</span><span class='line'>
</span><span class='line'>branch predictor sequence length:17
</span><span class='line'>99999
</span><span class='line'>
</span><span class='line'> Performance counter stats for 'java GGG 7':
</span><span class='line'>
</span><span class='line'>        837.196938 task-clock                #    0.999 CPUs utilized          
</span><span class='line'>               165 context-switches          #    0.000 M/sec                  
</span><span class='line'>                 8 CPU-migrations            #    0.000 M/sec                  
</span><span class='line'>             4,202 page-faults               #    0.005 M/sec                  
</span><span class='line'>     2,497,386,962 cycles                    #    2.983 GHz                     [49.25%]
</span><span class='line'>   &lt;not supported> stalled-cycles-frontend 
</span><span class='line'>   &lt;not supported> stalled-cycles-backend  
</span><span class='line'>     1,514,795,880 instructions              #    0.61  insns per cycle         [75.21%]
</span><span class='line'>       401,526,259 branches                  #  479.608 M/sec                   [75.18%]
</span><span class='line'>        39,563,587 branch-misses             #    9.85% of all branches         [75.67%]
</span><span class='line'>
</span><span class='line'>       0.838282370 seconds time elapsed
</span><span class='line'>
</span><span class='line'>test case:8
</span><span class='line'>
</span><span class='line'>branch predictor sequence length:32
</span><span class='line'>100000
</span><span class='line'>
</span><span class='line'> Performance counter stats for 'java GGG 8':
</span><span class='line'>
</span><span class='line'>        747.169398 task-clock                #    1.006 CPUs utilized          
</span><span class='line'>               178 context-switches          #    0.000 M/sec                  
</span><span class='line'>                51 CPU-migrations            #    0.000 M/sec                  
</span><span class='line'>             4,199 page-faults               #    0.006 M/sec                  
</span><span class='line'>     2,231,730,222 cycles                    #    2.987 GHz                     [50.33%]
</span><span class='line'>   &lt;not supported> stalled-cycles-frontend 
</span><span class='line'>   &lt;not supported> stalled-cycles-backend  
</span><span class='line'>     1,630,954,802 instructions              #    0.73  insns per cycle         [75.53%]
</span><span class='line'>       438,123,215 branches                  #  586.377 M/sec                   [74.94%]
</span><span class='line'>        30,522,725 branch-misses             #    6.97% of all branches         [74.87%]
</span><span class='line'>
</span><span class='line'>       0.742440916 seconds time elapsed
</span><span class='line'>
</span><span class='line'>test case:9
</span><span class='line'>
</span><span class='line'>branch predictor sequence length:33
</span><span class='line'>100000
</span><span class='line'>
</span><span class='line'> Performance counter stats for 'java GGG 9':
</span><span class='line'>
</span><span class='line'>        970.124951 task-clock                #    1.006 CPUs utilized          
</span><span class='line'>               197 context-switches          #    0.000 M/sec                  
</span><span class='line'>                51 CPU-migrations            #    0.000 M/sec                  
</span><span class='line'>             4,202 page-faults               #    0.004 M/sec                  
</span><span class='line'>     2,897,829,158 cycles                    #    2.987 GHz                     [49.89%]
</span><span class='line'>   &lt;not supported> stalled-cycles-frontend 
</span><span class='line'>   &lt;not supported> stalled-cycles-backend  
</span><span class='line'>     1,615,586,420 instructions              #    0.56  insns per cycle         [75.29%]
</span><span class='line'>       432,153,910 branches                  #  445.462 M/sec                   [74.86%]
</span><span class='line'>        51,106,599 branch-misses             #   11.83% of all branches         [75.29%]
</span><span class='line'>
</span><span class='line'>       0.964319417 seconds time elapsed</span></code></pre></td></tr></table></div></figure>


<p>以上测试不严谨的地方在于没有多次测试并取平均值,但经过人肉的repeat和肉眼的分析来看,测试数据表现出的特征很明显,所有测试序列长度大于2的结果中,为2的幂次+1的结果都在分支预测上表现不理想,同时当序列长度等于32时,结果要明显高于小于等于16的2的幂次的结果.</p>

<p>这个场景很特别,也有很多值得思考的问题,目前没有很明确的答案,只有一些基本的猜测:</p>

<ol>
<li><p>仔细看看,发现if条件中的第二个表达式在内循环中由于i的不变性而保持不变,第一个条件虽然会发生变化,但其值具备很强的可预测性,因为在去掉第二个条件后,miss率降到3%左右.而将第二个表达式前提后,miss率也降低到3%.
这个现象十分之诡异,也难以解释,准备试试vtune,看能否采集到更精准的数据来分析.</p></li>
<li><p>计算机喜欢2的幂次</p>

<ul>
<li>刚毕业那会某大牛对我说,如果你要使用一个数字变量,尽量定义为2的幂次.当然长度16以后的性能剧降能间接的说明了解branch history长度的意义.</li>
<li>2的幂次+1带来的更多的随机性和资源的负担,我只能说记住第一条,但无法量化分析这个现象,如果真要分析,有机会进intel我会好好研究~.</li>
</ul>
</li>
</ol>


<h2>结论</h2>

<ol>
<li>2的幂次</li>
<li>优化hotspot,尽量消除不必要的分支,如果必须要使用,注意分析branch内表达式的随机性.</li>
<li>分析分支预测失败因子基于了解当前CPU内部架构的基础上.</li>
</ol>


<h2>参考</h2>

<ul>
<li><a href="http://zh.wikipedia.org/zh/%E5%88%86%E6%94%AF%E9%A0%90%E6%B8%AC%E5%99%A8">分支预测器</a></li>
<li><a href="http://software.intel.com/en-us/articles/avoiding-the-cost-of-branch-misprediction">intel开发者blog-如何避免分支预测失败的开销</a></li>
<li><a href="http://www.docin.com/p-86138919.html">某教授对各种类似CPU内部架构的分析和猜测, 专业!</a></li>
<li><a href="http://en.wikipedia.org/wiki/Loop_unwinding">loop unrolling</a></li>
<li><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15740-f02/public/doc/discussions/uniprocessors/branch_pred/msmith_isca95.pdf">分支预测分析</a></li>
</ul>


<p>intel官方文档我没有找到对于分支预测的详细介绍,很多地方都是一笔带过.这里就不列举了.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[循环效率的纠结]]></title>
    <link href="http://songjie-dong.github.com/blog/2012/11/08/xun-huan-xiao-lu-de-jiu-jie/"/>
    <updated>2012-11-08T10:13:00+08:00</updated>
    <id>http://songjie-dong.github.com/blog/2012/11/08/xun-huan-xiao-lu-de-jiu-jie</id>
    <content type="html"><![CDATA[<h2>纠结</h2>

<p>两个嵌套的循环,一个假设10000000次,一个假设100次,把两个循环次数颠倒一下,是否存在性能差异的问题.</p>

<h2>解释执行</h2>

<p>从代码来分析,如果外层循环较大,则内层循环的循环变量会被更多次的使用,这是个隐性的开销,而内层循环里的代码,在两种情况下执行指令的次数是一致的,所以外层循环较大则性能较差.</p>

<h2>JIT</h2>

<p>通常循环达到一定的次数回边计数超过阀值,则触发JIT编译,而后上述基于栈的指令体系下出现的指令数差异则不复存在了,而需要看编译后的差异,这个差异在不同的机器上表现有些不一样,即使是同样的环境,而会略有不同,但用perf分析后,发现执行的指令数,耗时,分支预测错误率,线程cpu迁移都没有数量级的差异.可以说性能基本一致.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字节序与java]]></title>
    <link href="http://songjie-dong.github.com/blog/2012/11/07/zi-jie-xu-yu-java/"/>
    <updated>2012-11-07T01:13:00+08:00</updated>
    <id>http://songjie-dong.github.com/blog/2012/11/07/zi-jie-xu-yu-java</id>
    <content type="html"><![CDATA[<p>所谓字节序也就是字节在内存中存放的顺序,分为大端(big endian,低位存放高字节)和小端(little endian,低位存放低字节),再来又有主机序和网络序之说,主机序就是当前主机的字节序,说白点就是CPU的字节序,而CPU的字节序由于历史原因,分为不同的阵营,intel是小端,摩托,IBM,SUN则是大端,至于java,不用说,肯定得站对队伍了.使用c语言可以很快速的判断当前机器的endian,int i = 1 变量强转char*,这样可以取到低位值判断是否任然等于1即可.网络序就是在网络传输过程中的顺序,基于未知原因(有人说是抛硬币决定),网络序固定为big endian,不管怎样,固定更加有利于我们程序的健壮性,因为我们只需要处理一种情况,同时也可以节约码农的时间,避免诡异的错误.</p>

<p>废话完毕,说说java中的字节序,网上传言java都是big endian,这个观点本身由于说的太绝对是有一些误导性的,特别是对于以上内容了解不细致的时候,其实作为java来说只是在规范中约定了class文件和操作数都是big endian,同时也有人补充说明所有的流都是big endian,<a href="http://docs.oracle.com/javase/6/docs/api/java/nio/ByteOrder.html#nativeOrder%28%29">nativeOrder</a>可以读取当前机器的字节序作为参考,只在性能极其敏感的场景在所分配的direct buffer实现与硬件一致的字节序.所以在java中我们定义一个int变量并赋值后,变量本身的字节序任然取决于硬件本身,不要被误导了.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[此时此刻]]></title>
    <link href="http://songjie-dong.github.com/blog/2012/11/06/ci-shi-ci-ke/"/>
    <updated>2012-11-06T15:05:00+08:00</updated>
    <id>http://songjie-dong.github.com/blog/2012/11/06/ci-shi-ci-ke</id>
    <content type="html"><![CDATA[<p>最近看了钱老说的一句话:一个人,到了20岁还不狂，这个人是没出息的；到了30岁还狂，也是没出息的。</p>

<p>以此句开头颇有意味,20岁的时候我还没狂,只是把无处安放的青春献给了网吧,一晃就29岁啦,赶上了20岁狂的那拨人,但还是隐隐感到有危机.</p>

<p>有时候感觉到到有心无力,特别是每当把问题研究到比较深入领域时,我总是会感觉有某种障碍在阻拦我的前进,于是我在近一两年开始有意识的结构化很多计算机本知识,回归到最原始的途径来学习,如今看来确实小有收获,但知识体系尚未完全建立,很多常识性的知识还有待进一步的积累,但怎奈环境一直不够给力.</p>

<p>如此情况下,我看30岁是不可能狂的,这样也好,应了钱老的后半句句话,否则真没出息怎么办,O(∩_∩)O~,我要从新扬帆起航,虽然知道放弃自己所熟悉的领域,去探索未知的世界,对于这个世俗的世界来说是个极大的风险,但我还是想义无反顾的去尝试让自己有更多的可能性.此时此刻,为了以后的出息而努力吧.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[is parallel programming hard? -1]]></title>
    <link href="http://songjie-dong.github.com/blog/2012/10/26/is-parallel-programming-hard-1/"/>
    <updated>2012-10-26T18:10:00+08:00</updated>
    <id>http://songjie-dong.github.com/blog/2012/10/26/is-parallel-programming-hard-1</id>
    <content type="html"><![CDATA[<h2>迷思</h2>

<p>“Is Parallel Programming Hard, And, If So, What Can You Do About It?”,这本书很久就知道,一直没怎么看过,多半对于并行的理解来自于工作中需要对java处理并行的方式有一定的了解,所以看了不少关于JVM内存模型,线程安全控制,doug lea的并发包处理,深入理解计算机等等相关的书籍,文档和blog,但知识体系不够完整,所以这个系列记录一些阅读本书的笔记</p>

<h2>关于CPU</h2>

<p>作者开篇介绍了有些粗心的人对于CPU的理解就像在没有障碍的赛道上跑步,总能保持较快的速度,但事实上除了一些计算密集型的场景以外,绝大多数的程序相比于竞速赛跑来说更像是越野障碍赛,下面我们就一起看看有哪些障碍.</p>

<h3>流水线</h3>

<p>现代CPU引入了流水线机制,将不同指令放到不同的流水线执行,这意味着在微观世界里,指令执行的顺序很可能与我们看到的不一样,但会保证执行结果的一致性,这就是指令的重排序过程,重排序可以更充分的利用cpu的流水线机制更迅速的执行指令.但重排序机制也引入了一个问题:需要预取指令,这对于在运行时的条件分支预测提出了挑战,如果你在一个频繁执行的循环中加入一个if else,而这个if else的分支路线分布随机,则难以预测,进而导致流水线无法充分利用,降低系统整体性能.</p>

<h3>内存读写</h3>

<p>CPU的性能的提升速度明显高于内存的访问性能,这导致了CPU访问内存逐渐成为了瓶颈,于是高速缓存的命中率对于性能来说至关重要,而类似链表这种结构显然就不是缓存友好的结构,数组则更加适合(空间局部性).对于单核来说高速缓存能很好的解决内存访问的性能瓶颈,对于多核来说则引入了而外的问题.</p>

<h3>atomic&amp;memory barrier</h3>

<p>现代CPU都提供了原子操作的指令,该指令保证了对单个数据操作的原子性和可见性,memory barrier就是用来保证指令的顺序不会由于重排序破坏了原子性.但barrier机制降低了流水线的使用效率,另外atomic操作结束会将数据直接写内存,保证可见性.</p>

<h3>cache misses</h3>

<p>多核的cache各自独立,进而导致了我们需要避免缓存数据在多个核存在的情况,这会导致cpu之间相互传递数据,引入而外的开销(false sharing),作者在后续文章中提到关于数组实现的并发的计数器设计中需要考虑在数组中增加填充物来避免false sharing问题.</p>

<h2>编程</h2>

<p>以单核平均执行指令数来衡量并行的性能,以上述机制来分析,需要关注的点:</p>

<h3>cache misses</h3>

<p>高速缓存的命中率问题,我们要关注context switch的次数,这就需要间接的关注程序中可能的block因素,IO,锁等等都可能block线程导致context switch.
而context switch后高速缓存需要重新warm-up</p>

<p>过多的线程迁移也会导致类似的问题.</p>

<p>空间局部性,多用数组这种结构,但要注意多核的false sharing问题.</p>

<p>时间局部性</p>

<p>避免不必要的同步和原子操作,有时它们会强制访问内存数据.</p>

<h3>分支预测</h3>

<p>写出分支预测友好的代码,必要情况下可以hard coding或者用mapping来消除if else</p>

<h3>共享</h3>

<p>共享数据总是万恶之源.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[再看面向对象]]></title>
    <link href="http://songjie-dong.github.com/blog/2012/10/16/zai-kan-mian-xiang-dui-xiang/"/>
    <updated>2012-10-16T15:52:00+08:00</updated>
    <id>http://songjie-dong.github.com/blog/2012/10/16/zai-kan-mian-xiang-dui-xiang</id>
    <content type="html"><![CDATA[<h2>初次见面</h2>

<p>初学OO是在学习Java时,当时感觉OO像是巴别塔,迷恋的人觉得无比的向往,于是猛啃侯捷版的Thinking in java中那几章继承多态啥的,不知道看过多少遍,而后看设计模式(不夸张,期间还有coding例子加冥想体会),当时自我感觉略懂,能用,但写起代码还是有些手足无措.后续又有了很多这方面的书籍,例如:重构-改善既有代码的设计,类似这样的书翻了不少,感觉找到了救世主,最后发现自己严重的教条化,xx代码太长不爽,if太多不爽,没用到模式也不爽,甚至听到每个方法不超过5行这种YY都心潮澎湃.</p>

<h2>我的问题</h2>

<p>OO作为一个时代发展的产物本身没有问题,60年代就出现了OO的概念,后续也出现了一些语言支持,90年代相关理论基本已经完善,等到我学的时候,接触到的都是一些最直接的概念以及大牛们迷恋式的布道,当时的学习方式就是记住相关概念,拜读大牛书籍,然后按模式coding.这样的学习过程带来了极大的问题,因为我把OO看的太形而上,把OO当救世主,认为OO能作为一个可理解性极好的模型来描述世界,殊不知OO并非完美.</p>

<h2>回顾历史</h2>

<p>人们发现当软硬件日益复杂化,代码的维护成本越来越高,需要有一种更加有效和直观的方式来组织不同的代码单元,降低耦合,提高可维护性.60年代OO概念开始出现,后续出现多种支持OOP的语言,相关的概念也逐步形成:动态分派,封装,继承,多态,开放递归等等.对比类似c的以function来组织代码单元的方式,OO则以object作为一等公民,每个object都具备了接收消息,处理数据,发送消息的能力,对象与对象之间通过消息通讯,对象作为系统内部一个独立的&#8221;机器&#8221;,具备独立的状态和能力,用这样的方式,OO同样提供了有效组织代码单元,代码重用,模块化协作的能力.</p>

<h2>问题</h2>

<p>在把OO作为巴别塔的人群中,人们很自然的传播着对于OO的迷恋,但OO并非完美的理论, Bertrand Meyer argues in Object-Oriented Software Construction[21] that a program is not a model of the world but a model of some part of the world,后续也出现了经典的问题,如圆和椭圆的问题.</p>

<p>object作为一等公民,对象成为代码组织方式的核心,进而引入了潜在的易变性问题,而后有人总结并提出面向接口编程,为什么,因为接口才是契约,它无状态,任何的实现必须符合接口提供的规范,同样的输入得到同样的输出,simple and easy,有了这个契约我们才真正的无需关心细节!但我们不能什么都基于接口来编程,我们需要把握某种度,而这种度似乎无法完全掌握,需要case by case.美好的OO编程,其实不像很多迷恋者想的,能够自然且方便的编程,如果没有一些深入的学习,例如了解OO相关的发展过程,概念,优势和劣势等等.我想,用OO写的程序比procedure-oriented更容易出错,而且更容易在程序日益复杂后变得无法维护,难以解耦,可测试性无法与procedure-oriented相比.这显然是有些违背了OO的初衷,同时我们也发现OO其实不是看上去那么易于上手.</p>

<p>同样的输入得到同样的输出(Design By Contract),当我们的程序能够符合某种契约时,很多问题都变得更加的简单化,例如用FP来编程,function作为一等公民,没有易变性,function是比Object更小的单元,可以玩出很多OO中无法玩出的花样,例如闭包,更容易的代码重用,更强的可测试性.所以有很多大牛们推荐学习FP,不是说我们都直接用FP,而是通过对比能更好的看清OO的问题并在日后的coding中借鉴FP的理念.毕竟OO天生就不完美,它与编程的本质似乎存在阻抗不匹配.</p>

<p>OO对于并发的影响大牛们也提到了,这个点我还没明确,现在能想到的是在多核环境下,需要很小心的处理数据的组织形式和读写(缓存抖动,作色,缓存命中率),而OO则天然的决定了数据的组织形式不能从计算机本质的角度出发,后续再分析吧.</p>

<h2>启示</h2>

<ul>
<li>找个FP语言学学,有很多好处</li>
<li>应付应试教育的那套学习方法总是无法带来对本质的认知,而只有挖掘本质才能顿悟.</li>
</ul>


<h2>参考</h2>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Object-oriented">OO Wikipedia</a></li>
<li><a href="http://en.wikipedia.org/wiki/Object-oriented">Design By Contract</a></li>
<li><a href="http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey">Are We There Yet?</a>
这篇文章偶会再分析分析,作者level太高,演讲信息量极大,还有些不理解,后续再记录心得.</li>
<li><a href="http://en.wikipedia.org/wiki/Object-Oriented_Software_Construction">OO software construction</a>
这本书没有中文版,国内关注的人很少(这个结论来自于<a href="http://book.douban.com/subject/1547078/">豆瓣上的关注度</a>),然而却被广泛的认为是OOP的经典之作,可以作为众多计算机书籍的参考标准,并在1994年获得Jolt大奖,不知道有多少人都在OO的世界里迷茫,看完以上资料或许您就能被救赎.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[weak reference 原理分析]]></title>
    <link href="http://songjie-dong.github.com/blog/2012/10/11/weak-reference-yuan-li-fen-xi/"/>
    <updated>2012-10-11T12:33:00+08:00</updated>
    <id>http://songjie-dong.github.com/blog/2012/10/11/weak-reference-yuan-li-fen-xi</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>若干年前看了Java的四种引用类型，只是简单知道了不同类型的作用，但对其实现原理一直未能想明白，本文尝试结合jdk，openjdk6的部分源码分析弱引用实现的原理，供大家参考，部分技术细节没有仔细研究，如有疑问欢迎留言讨论</p>

<h2>实例分析</h2>

<p>我们以WeakHashMap的处理过程为例介绍一个weak reference的生命周期，首先我们调用WeakHashMap的put方法放入对象到Map中，WeakHashMap的Entry继承了WeakReference</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>   <span class="kd">private</span> <span class="n">V</span> <span class="n">value</span><span class="o">;</span>
</span><span class='line'>   <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">;</span>
</span><span class='line'>   <span class="kd">private</span> <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面是put的部分代码</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>        <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;(</span><span class="n">k</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">queue</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(++</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="o">)</span>
</span><span class='line'>            <span class="n">resize</span><span class="o">(</span><span class="n">tab</span><span class="o">.</span><span class="na">length</span> <span class="o">*</span> <span class="mi">2</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意new Entry传递了一个reference queue到构造函数中，此构造函数最终会调用Reference的构造函数</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>
</span><span class='line'><span class="n">Reference</span><span class="o">(</span><span class="n">T</span> <span class="n">referent</span><span class="o">,</span> <span class="n">ReferenceQueue</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">this</span><span class="o">.</span><span class="na">referent</span> <span class="o">=</span> <span class="n">referent</span><span class="o">;</span>
</span><span class='line'>    <span class="k">this</span><span class="o">.</span><span class="na">queue</span> <span class="o">=</span> <span class="o">(</span><span class="n">queue</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">ReferenceQueue</span><span class="o">.</span><span class="na">NULL</span> <span class="o">:</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>referent是我们之前传入的hashmap的key对象，queue的作用是用来读取referent被回收的weak reference，生产者是谁后续介绍，此时WeakHashMap中已经存在了一个对象，先将key对象的strong ref制空并尝试触发gc，比如使用System.gc()来显式的触发gc，然后调用WeakHashMap的size方法返回集合的个数，绝大多数情况下会是0，这个过程中发生了什么呢？</p>

<p>第一步，key没有可达的strong ref，仅仅存在一个weak reference的referent变量仍然指向了key，触发GC时，以openjdk6的parNew为例，jvm在young generation gc时会尝试获取Reference对象里的静态全局锁</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/* Object used to synchronize with the garbage collector.  The collector </span>
</span><span class='line'><span class="cm">     * must acquire this lock at the beginning of each collection cycle.  It is </span>
</span><span class='line'><span class="cm">     * therefore critical that any code holding this lock complete as quickly </span>
</span><span class='line'><span class="cm">     * as possible, allocate no new objects, and avoid calling user code. </span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">static</span> <span class="kd">private</span> <span class="kd">class</span> <span class="nc">Lock</span> <span class="o">{</span> <span class="o">};</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Lock</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>在openjdk6里的部分源代码,完整代码请参考instanceRefKlass.cpp文件</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="n">instanceRefKlass</span><span class="o">::</span><span class="n">acquire_pending_list_lock</span><span class="p">(</span><span class="n">BasicLock</span> <span class="o">*</span><span class="n">pending_list_basic_lock</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// we may enter this with pending exception set </span>
</span><span class='line'>  <span class="n">PRESERVE_EXCEPTION_MARK</span><span class="p">;</span>  <span class="c1">// exceptions are never thrown, needed for TRAPS argument </span>
</span><span class='line'>  <span class="n">Handle</span> <span class="n">h_lock</span><span class="p">(</span><span class="n">THREAD</span><span class="p">,</span> <span class="n">java_lang_ref_Reference</span><span class="o">::</span><span class="n">pending_list_lock</span><span class="p">());</span>
</span><span class='line'>  <span class="n">ObjectSynchronizer</span><span class="o">::</span><span class="n">fast_enter</span><span class="p">(</span><span class="n">h_lock</span><span class="p">,</span> <span class="n">pending_list_basic_lock</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">THREAD</span><span class="p">);</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">(</span><span class="n">ObjectSynchronizer</span><span class="o">::</span><span class="n">current_thread_holds_lock</span><span class="p">(</span>
</span><span class='line'>           <span class="n">JavaThread</span><span class="o">::</span><span class="n">current</span><span class="p">(),</span> <span class="n">h_lock</span><span class="p">),</span>
</span><span class='line'>         <span class="s">&quot;Locking should have succeeded&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">HAS_PENDING_EXCEPTION</span><span class="p">)</span> <span class="n">CLEAR_PENDING_EXCEPTION</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p> 此处代码在parNew gc时执行，目的就是尝试获取全局锁，在gc完成后，jvm会将key被回收的weak reference组成一个queue并赋值到Reference的pending属性然后释放锁，参考方法：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="n">instanceRefKlass</span><span class="o">::</span><span class="n">release_and_notify_pending_list_lock</span><span class="p">(</span>
</span><span class='line'>  <span class="n">BasicLock</span> <span class="o">*</span><span class="n">pending_list_basic_lock</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// we may enter this with pending exception set </span>
</span><span class='line'>  <span class="n">PRESERVE_EXCEPTION_MARK</span><span class="p">;</span>  <span class="c1">// exceptions are never thrown, needed for TRAPS argument </span>
</span><span class='line'>  <span class="c1">// </span>
</span><span class='line'>  <span class="n">Handle</span> <span class="n">h_lock</span><span class="p">(</span><span class="n">THREAD</span><span class="p">,</span> <span class="n">java_lang_ref_Reference</span><span class="o">::</span><span class="n">pending_list_lock</span><span class="p">());</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">(</span><span class="n">ObjectSynchronizer</span><span class="o">::</span><span class="n">current_thread_holds_lock</span><span class="p">(</span>
</span><span class='line'>           <span class="n">JavaThread</span><span class="o">::</span><span class="n">current</span><span class="p">(),</span> <span class="n">h_lock</span><span class="p">),</span>
</span><span class='line'>         <span class="s">&quot;Lock should be held&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">// Notify waiters on pending lists lock if there is any reference. </span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">java_lang_ref_Reference</span><span class="o">::</span><span class="n">pending_list</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">ObjectSynchronizer</span><span class="o">::</span><span class="n">notifyall</span><span class="p">(</span><span class="n">h_lock</span><span class="p">,</span> <span class="n">THREAD</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">ObjectSynchronizer</span><span class="o">::</span><span class="n">fast_exit</span><span class="p">(</span><span class="n">h_lock</span><span class="p">(),</span> <span class="n">pending_list_basic_lock</span><span class="p">,</span> <span class="n">THREAD</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">HAS_PENDING_EXCEPTION</span><span class="p">)</span> <span class="n">CLEAR_PENDING_EXCEPTION</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在一次gc后，Reference对象的pending属性不再为空，让我们看看Reference的部分代码
首先是pending属性的说明：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/* List of References waiting to be enqueued.  The collector adds </span>
</span><span class='line'><span class="cm"> * References to this list, while the Reference-handler thread removes </span>
</span><span class='line'><span class="cm"> * them.  This list is protected by the above lock object. </span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="n">Reference</span> <span class="n">pending</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来是Reference中的内部类ReferenceHandler，它继承了Thread，看看run方法的代码</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">Reference</span> <span class="n">r</span><span class="o">;</span>
</span><span class='line'>        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">pending</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">r</span> <span class="o">=</span> <span class="n">pending</span><span class="o">;</span>
</span><span class='line'>            <span class="n">Reference</span> <span class="n">rn</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class='line'>            <span class="n">pending</span> <span class="o">=</span> <span class="o">(</span><span class="n">rn</span> <span class="o">==</span> <span class="n">r</span><span class="o">)</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">rn</span><span class="o">;</span>
</span><span class='line'>            <span class="n">r</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">lock</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
</span><span class='line'>            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="o">}</span>
</span><span class='line'>            <span class="k">continue</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Fast path for cleaners </span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="k">instanceof</span> <span class="n">Cleaner</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="o">((</span><span class="n">Cleaner</span><span class="o">)</span><span class="n">r</span><span class="o">).</span><span class="na">clean</span><span class="o">();</span>
</span><span class='line'>            <span class="k">continue</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">ReferenceQueue</span> <span class="n">q</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="na">queue</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">q</span> <span class="o">!=</span> <span class="n">ReferenceQueue</span><span class="o">.</span><span class="na">NULL</span><span class="o">)</span> <span class="n">q</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>一旦jvm notify了前面提到的锁，这个线程就被激活并开始执行，作用是将之前jvm赋值过来的pending对象中的WeakReference对象enqueue到指定的队列中，比如WeakHashMap内部定义的ReferenceQueue属性
此时map的queue中保存了referent已经被回收的WeakReference队列，也就是map的Entry对象，当调用size方法时，内部首先调用expungStaleEntries方法清除被回收掉的Entry，代码如下</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">expungeStaleEntries</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span> <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">hash</span><span class="o">;</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">indexFor</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">table</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>            <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
</span><span class='line'>            <span class="k">while</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                    <span class="k">if</span> <span class="o">(</span><span class="n">prev</span> <span class="o">==</span> <span class="n">e</span><span class="o">)</span>
</span><span class='line'>                        <span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'>                    <span class="k">else</span>
</span><span class='line'>                        <span class="n">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'>                    <span class="n">e</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>  <span class="c1">// Help GC </span>
</span><span class='line'>                    <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">//  &quot;   &quot; </span>
</span><span class='line'>                    <span class="n">size</span><span class="o">--;</span>
</span><span class='line'>                    <span class="k">break</span><span class="o">;</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>                <span class="n">prev</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
</span><span class='line'>                <span class="n">p</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>ok，就这样map的废弃Entry被clear，size返回为0</p>

<h2>参考</h2>

<ul>
<li><a href="http://weblogs.java.net/blog/2006/05/04/understanding-weak-references">understanding-weak-references</a></li>
<li><a href="http://stackoverflow.com/questions/154724/when-would-you-use-a-weakhashmap-or-a-weakreference">when-would-you-use-a-weakhashmap-or-a-weakreference</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BDB学习笔记]]></title>
    <link href="http://songjie-dong.github.com/blog/2012/10/11/bdbxue-xi-bi-ji/"/>
    <updated>2012-10-11T11:37:00+08:00</updated>
    <id>http://songjie-dong.github.com/blog/2012/10/11/bdbxue-xi-bi-ji</id>
    <content type="html"><![CDATA[<h2>介绍</h2>

<p>Berkeley DB (DB)是一个高性能的，嵌入数据库，和C语言，C++，Java，Perl，Python，PHP，Tcl以及其他很多语言都有绑定。Berkeley DB可以保存任意类型的键/值对，而且可以为一个键保存多个数据。Berkeley DB可以支持数千的并发线程同时操作数据库，支持最大256TB的数据，广泛用于各种操作系统包括大多数Unix类操作系统和Windows操作系统以及实时操作系统。</p>

<p>在工作中使用的是java版本的bdb( Berkeley DB 以下简称为bdb)，主要用来存储计算结果提供给业务系统访问，比如数据挖掘的结果，这类数据定期会刷新，访问形式单一，存在数据库有点大材小用，另外就是存储大量的计算中间结果。总体来说bdb的性能非常不错，但在使用时还是遇到了一些问题，总结一些经验教训</p>

<h3>问题1：定期build大量计算结果</h3>

<p>实际使用时，写入千万数据后，写入性能急剧下降，但硬盘还在飞转，调节了很多的系统参数，关闭了事务，调大了btree索引缓存(根据bdb内部的DbCacheSize工具调节)，jvm启动参数等等(怀疑是fgc的问题)，都没有解决问题，最后调节了写入数据的顺序才解决了问题，一开始我们没有对写入数据的key排序，而随机写入大量数据导致了btree索引性能的下降，改为顺序写入后，问题解决。那如何解释硬盘飞转呢，其实是由于写操作频繁触发btree结构调整导致。</p>

<h3>问题2：性能测试出现少量lock timeout，软硬件环境不同出现的次数也不同</h3>

<p>默认的locktimeout是500ms，而我们在并发读写的性能测试时出现了少量的timeout情况，32位环境（jdk1.5）下较少，64位环境(jdk1.6)下较多，500ms的timeout，在非高性能要求的环境下，貌似还是短了点。问题是为什么对于不同的环境，出现timeout的次数差距较明显，多次测试发现32位环境出现的较少，64位环境出现的较多，com.sleepycat.je.util.DbCacheSize这个工具让我发现了一些线索，原来我一直以为这个工具就是粗略根据分支节点大概的大小，总数据量，key大小就可以帮助我们计算出大致的索引cache size，比如1000万数据，key长20byte的cache size：</p>

<pre><code>Inputs: records=10000000 keySize=20 dataSize=8092 nodeMax=128 density=80% overhead=10%
Cache Size      Btree Size  Description
871,284,622     784,156,160  Minimum, internal nodes only  
1,180,450,133   1,062,405,120  Maximum, internal nodes only  
91,537,951,288  82,384,156,160  Minimum, internal nodes and leaf nodes  
91,847,116,800  82,662,405,120  Maximum, internal nodes and leaf nodes  
Btree levels: 4 
</code></pre>

<p>这个是在mac下的测试结果，而在32位的ubuntu下测试minimum internal nodes需要501M，主要的原因是由于在不同的环境对应的java对象占用内存大小不一致，而java本身没有提供动态检测对象占用内存大小的方法，在bdb中MemoryBudget类里面定义了不同环境下对应的常用对象的大小，所以，如果用同样的cachesize配置，在不同的环境下会表现出不同的性能，因为如果设置小了会导致部分索引的操作无法命中缓存，性能会有所下降，所以我推测timeout的频率不同的原因是由于固定的cachesize在不同的环境性能也会不同而导致。</p>

<h3>问题3：数据build需要注意的</h3>

<p>对于大数据量写入bdb，同时需要把数据文件跨地区传输时，有一个小的tips，就是在你build完数据以后，close environment后，重新开启一个只读的environment，设置启动参数：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>
</span><span class='line'><span class="n">je</span><span class="o">.</span><span class="na">env</span><span class="o">.</span><span class="na">runCleaner</span> <span class="err">＝</span> <span class="kc">false</span>
</span><span class='line'><span class="n">je</span><span class="o">.</span><span class="na">cleaner</span><span class="o">.</span><span class="na">minUtilization</span> <span class="err">＝</span> <span class="mi">90</span>
</span><span class='line'>
</span><span class='line'><span class="k">while</span> <span class="o">(</span><span class="n">environment</span><span class="o">.</span><span class="na">cleanLog</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;clean log &quot;</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="n">CheckpointConfig</span> <span class="n">cleanCheckpointConfig</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CheckpointConfig</span><span class="o">()</span>
</span><span class='line'><span class="n">cleanCheckpointConfig</span><span class="o">.</span><span class="na">setForce</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
</span><span class='line'><span class="n">environment</span><span class="o">.</span><span class="na">checkpoint</span><span class="o">(</span><span class="n">cleanCheckpointConfig</span><span class="o">);</span>
</span><span class='line'><span class="n">environment</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>加上如上代码，这样就可以清除掉大部分废弃的log信息，把文件缩小，这样传输时间会省不少，特别在带宽受限的情况下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[阿里入职培训的感受]]></title>
    <link href="http://songjie-dong.github.com/blog/2012/10/11/a-li-ru-zhi-pei-xun-de-gan-shou/"/>
    <updated>2012-10-11T11:30:00+08:00</updated>
    <id>http://songjie-dong.github.com/blog/2012/10/11/a-li-ru-zhi-pei-xun-de-gan-shou</id>
    <content type="html"><![CDATA[<p>短暂的百年阿里之旅，仿佛让我又回到了大学时代，大家一起做游戏，一起感悟人生，一起体会阿里的价值观，也留下了很多难忘的回忆。</p>

<p>在这里我结识了一帮朋友，大家一起在游戏中，在讲师的各种故事中慢慢的体会到什么是客户第一，团队合作，拥抱变化，激情，敬业，诚信。为了小组最后的价值观表演我们连续两天排练到很晚，回家睡觉时都两点了，最后我还献出了人生中第一次的反串（感觉阿里人都好这口），难忘拓展时大家挺着烈日完成了一个个的任务，彼此信任，互相鼓励，我所在的团队还拿到了最后的冠军，我也得到了一枚小太阳虽然这枚小太阳我弄丢了，但是团队中每一个成员都没有因此责怪我。另外对于团队这两个字的我现在有了更深刻的认识，那就是行动前需要周密的计划与决策，一旦决定，团队必须坚决的执行，除非决策者提出新的方案，只有这样才能保证在高标准，高压力的工作中不断的前进。</p>

<p>对于工作三年的我来说，也经历了很多的事，心中的那个杯子早已不再是空的，我有自己的价值观对于各种事情都有自己很主观的看法，我很明确自己的目标。在培训期间我一直在思考，因为在这里，在阿里有些不一样的东西，有些是我早已忘却的宝贵东西，现在我又重新找到了，很庆幸我能够参加这次培训，它给了我很多，很多。。。</p>

<p>David说了一个字，我印象深刻，那就是德字，在目前的中国，乃至放眼全球，有多少企业能做到这个德字，又有多少企业家在慢慢的丢失掉自己的德。百年阿里，这是个伟大的事业，我也愿意与所有的阿里同仁们一起为这个事业添砖加瓦！从现在开始我任然不是空杯，只是杯子里的水不再浑浊。</p>

<hr />

<p>这篇旧文很可爱&#8230;.希望我能永远保持有这样的心境</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[渐渐离去的战友们]]></title>
    <link href="http://songjie-dong.github.com/blog/2012/10/11/jian-jian-chi-qu-de-zhan-you-men/"/>
    <updated>2012-10-11T11:25:00+08:00</updated>
    <id>http://songjie-dong.github.com/blog/2012/10/11/jian-jian-chi-qu-de-zhan-you-men</id>
    <content type="html"><![CDATA[<p>5年前，当我们一群同学踌躇满志杀入IT行业，进入了职场打拼，我们都是怀着自己的梦想，希望通过自己的努力证明自己的能力，5年过去了，剩下了几个，又剩下几个还怀着梦想的人，更多的都是在养老或者混日子或者怨天尤人。</p>

<p>刚开始工作那会，我们经常聚会，吃吃喝喝，工作中的苦恼都消散在我们的酒桌上，某某技术基础较差，我们大家会建议他看什么什么书，或者就一些技术实现给予帮助，某某家庭生活有点问题，我们也会想方设法开导他，总之，虽然大家技术都一般，但是对于程序员这个职业我们还是充满了激情。</p>

<p>5年过去，大部分人都远离的原来的理想，有的人虽然还在从事程序员工作但是已经是行尸走肉，抱着干到30换行业的决心在坚持；有的人干着IT相关基层工作，已经不在coding，生活的依然困惑；有的人因为自身性格和综合能力问题，虽然有一定技术基础，但是无法适应环境，三天打渔，两天晒网，干活也只是为了挣点生活费；有的人自认为已经out了，无法跟随IT业飞速发展，被不断出现的新技术所累，慢慢丧失激情；有些人稍微混的好点，但也仅限于待遇，还是无法逃离所谓“中国程序员只能干到30”的魔咒，甚至自己都这么认为；即使有些混的不错了，但是满身都是职业病，对于IT业早已萌生退意。</p>

<p>5年了，这五年我们的聚会，交流越来越少，似乎每个人都有自己的想法，都过的不如意，大家都变得不愿意沟通，喜欢按自己想的来，伴随着中国经济的飞速发展，房价，物价的大涨，大多数人的如意算盘打错了，因为所谓的混若干年经验带来的不错的待遇如今已经无法满足我们的生活需求，IT高薪梦破灭，我们还需要更多的钱，于是我们在去寻找着更好待遇的时候，我们发现，这几年来大家一直都忽视了程序员混饭吃必须的东西：持续的对于技术的激情。我们失去的是我们的干家本领，于是所有的现象都不难解释了：“IT行业我受够了，干的太累了，别人随便做点生意都比我挣的多”，“搞技术太无聊了，如果在我再选一次，打死我也不选这个职业”，“最近检查出了很多职业病，哎，以后不能太拼命了，混着得了”，“技术还不都是那些东西，学起来也没意思”。</p>

<p>每次与战友们聊天我都能感受到大家不想干下去的想法，但是生活就是这样，5年了，你付出了什么，你就能得到什么，想着混经验待遇自然会涨，想着做几年技术就搞管理，想着怎么挣钱而不是怎么学好技术，诸如此类，很多时候我们都是在做错误的事情，哪怕是我们正确的做好了事情，但是本质上路走错了，我们很难再回头了，很伤感，眼看着大家离自己最初的梦想越来越远，生活原来是这么的残酷。</p>

<p>技术这活还是条很艰难的路，但是就像那首诗说的，既然我们选择了少有人走的路，我们就要走出属于自己的精彩，希望战友们以后的工作顺利，家庭幸福，即使大家都已不在IT圈打拼。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nagle 算法]]></title>
    <link href="http://songjie-dong.github.com/blog/2012/10/10/nagle-suan-fa/"/>
    <updated>2012-10-10T16:55:00+08:00</updated>
    <id>http://songjie-dong.github.com/blog/2012/10/10/nagle-suan-fa</id>
    <content type="html"><![CDATA[<p>在各种场合看到涉及网络通讯的代码时,总会到到TCP_NODELAY的设置,也就是绕过nagle算法,虽然了解这个算法的基本原理,但一直没有机会追根述源,看wikipedia上关于nagle算法的介绍,很详细,所以也懒得分析,直接简单翻译并记录一下该算法,以免后续总问自己这算法到底能功能用在哪?</p>

<h2>介绍</h2>

<p>nagle算法以其发明者john nagle命名,该算法通过减少在网络上传输的包来改进网络上传输的效率.</p>

<p>nagle在文档:Congestion Control in IP/TCP Internetworks中描述了所谓的&#8221;small packet problem&#8221;, 即当一个应用重复发送小块数据,通常大小只有1个byte.TCP的包体中有40byte的header(20byte的TCP信息,20byte的ipv4信息),而这会导致41个byte的包只有一个byte的有用信息,这是一个巨大的开销.这种情况常常出现在使用telnet会话时大部分键盘输入会生成一个byte有效数据并被立即传输时,更坏的是在慢速网络环境下,大量这样的包会在同一时间传输,会潜在的导致拥塞崩溃.</p>

<h2>pseudocode</h2>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'> <span class="k">if</span> <span class="n">there</span> <span class="n">is</span> <span class="k">new</span> <span class="n">data</span> <span class="n">to</span> <span class="n">send</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">the</span> <span class="n">window</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="n">MSS</span> <span class="n">and</span> <span class="n">available</span> <span class="n">data</span> <span class="n">is</span> <span class="o">&gt;=</span> <span class="n">MSS</span>
</span><span class='line'>      <span class="n">send</span> <span class="n">complete</span> <span class="n">MSS</span> <span class="n">segment</span> <span class="n">now</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="k">if</span> <span class="n">there</span> <span class="n">is</span> <span class="n">unconfirmed</span> <span class="n">data</span> <span class="n">still</span> <span class="n">in</span> <span class="n">the</span> <span class="n">pipe</span>
</span><span class='line'>        <span class="n">enqueue</span> <span class="n">data</span> <span class="n">in</span> <span class="n">the</span> <span class="n">buffer</span> <span class="n">until</span> <span class="n">an</span> <span class="n">acknowledge</span> <span class="n">is</span> <span class="n">received</span>
</span><span class='line'>      <span class="k">else</span>
</span><span class='line'>        <span class="n">send</span> <span class="n">data</span> <span class="n">immediately</span>
</span><span class='line'>      <span class="n">end</span> <span class="k">if</span>
</span><span class='line'>    <span class="n">end</span> <span class="k">if</span>
</span><span class='line'>  <span class="n">end</span> <span class="k">if</span>    
</span></code></pre></td></tr></table></div></figure>


<h2>问题</h2>

<p>80年代初,有个组织提交了名为TCP Delayed Acknowledgment的算法,该算法会合并多个ack包以达到提升效率的作用,最大的ack延迟为500ms.当两个算法同时启用时,出现write-write-read的顺序时则由于第二个写可能的延迟导致read时间过长.由于这个原因,TCP实现提供了一些应用接口来关闭nagle算法,通常这个可选项名为TCP_NODELAY.(关于write-write-read带来的问题还有些不是很清晰)</p>

<p>nagle算法适用于任何大小的数据,如果一次写请求需要发送的包跨度为 2n packets,则最后的数据包会被buffer,直到收到前一个包的ack消息,延迟会增加上百ms,而且是由于这个算法导致了额外的开销.如果数据大于一个packet时,requester或responser最好都关闭该算法.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ltrace学习]]></title>
    <link href="http://songjie-dong.github.com/blog/2012/10/10/ltracexue-xi/"/>
    <updated>2012-10-10T16:30:00+08:00</updated>
    <id>http://songjie-dong.github.com/blog/2012/10/10/ltracexue-xi</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[protocol buffer 设计分析]]></title>
    <link href="http://songjie-dong.github.com/blog/2012/09/26/protocol-buffer-she-ji-fen-xi/"/>
    <updated>2012-09-26T17:27:00+08:00</updated>
    <id>http://songjie-dong.github.com/blog/2012/09/26/protocol-buffer-she-ji-fen-xi</id>
    <content type="html"><![CDATA[<h2>诞生</h2>

<p>传说google在索引系统的充斥着这样的代码</p>

<figure class='code'><figcaption><span>ugly code by google  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'> <span class="k">if</span> <span class="o">(</span><span class="n">version</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="o">...</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">version</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">version</span> <span class="o">==</span> <span class="mi">5</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="o">...</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="o">...</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>各种通讯协议的维护,版本兼容性,大型分布式系统升级维护成本,性能低下等等皆是让人头痛的问题,最终它们憋不住了,整了个protocol buffer(以下简称pb)出来,pb主要关注通讯协议本身的设计,充分考虑到了之前的各种问题,并将这些繁文缛节的东西考虑到了设计中.</p>

<hr />

<h2>分析</h2>

<p>想到俺也曾经在一个子系统里整过n种协议的RPC,很痛苦,健壮的协议可以降低复杂系统依赖带来的巨大成本,比如某核心系统升级接口,发现以前DIY的二进制协议难以做到向下兼容,于是乎,得整出两套接口,然后让依赖系统缓慢升级,这个过程需要很多人肉的工作,开发成本,运维成本,安全成本,百人以上的技术团队如果经常有这样的升级,显然开发人员的幸福感会下降的很快.</p>

<h3>Hello world</h3>

<figure class='code'><figcaption><span>example message  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>  <span class="n">message</span> <span class="n">Person</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">required</span> <span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>  <span class="n">required</span> <span class="n">int32</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
</span><span class='line'>  <span class="n">optional</span> <span class="n">string</span> <span class="n">email</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">enum</span> <span class="n">PhoneType</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">MOBILE</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="n">HOME</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>    <span class="n">WORK</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">message</span> <span class="n">PhoneNumber</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">required</span> <span class="n">string</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>    <span class="n">optional</span> <span class="n">PhoneType</span> <span class="n">type</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">[</span><span class="k">default</span> <span class="o">=</span> <span class="n">HOME</span><span class="o">];</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">repeated</span> <span class="n">PhoneNumber</span> <span class="n">phone</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>一些对分析设计有用的信息,field的类型为协议的兼容性提供了参考,数据类型是平台无关的,message可以组合和继承,数据类型丰富,message的描述能力强,高级功能忽略先.</p>

<h3>设计关注点</h3>

<h4>Encoding</h4>

<p>message的编码方式决定了传输的数据大小,传输性能,还有decoding的性能,同时还要兼具扩展性,pb的编码对于数字类型做了很多的优化,基于<a href="https://developers.google.com/protocol-buffers/docs/encoding?hl=zh-CN">BaseVarints</a> 这种变长编码方式对整型数据编码,使用了标志位来标识传输数据单元的长度,对于小于2<sup>28</sup> 的数据来说,这种方式可以减少冗余传输量,对于大于2<sup>28</sup> 的数据最好用fixed类型,否则会多出一个byte.对于负数的优化更难以理解一点,对于varint来说,正数,特别是小正数,可以节省很多的空间,但是对于负数则不然,因为高位总是有标志位,所以必须至少按5个字节来存,但考虑到兼容性,比如int32<->int64之间的转换问题,则总是使用10个字节来varint的存储负数 <a href="https://groups.google.com/forum/?fromgroups=#!topic/protobuf/fU0SVchScA0">why nagetive int always use 10 bytes</a>,官方推荐使用sint这种类型,使用了zigzag这种方式来编码,基本思路是把负数变正数,这样就又可以发挥变长的优势了.基本上协议体内部的数字都是变长的.协议中使用了极少的协议体信息,相对与xml和json,很多元信息都在message中,只要通讯双方有兼容的message即可.这些二进制流在被读取时可以简单的通过一些位运算即可decoding,so性能自然在xml和json之上了.</p>

<h4>Message Extensible</h4>

<p>message定义本身具备较强的扩展性,但要注意类型和field type,否则会带来兼容性问题.</p>

<h4>Multi-Platform</h4>

<p>统一使用了LE编码顺序,message数据类型与平台无关,encoding与平台无关,提供了编译器,针对不同的语言生成stub,跨平台,隐藏细节.</p>

<h4>Compatibility</h4>

<p>message数据类型在encoding过程中考虑了一些兼容性的问题,在对message升级的过程中,常见情况下都是可以满足需求的,但还得好好研究下官方对于message升级的说明,否则可能带来一些困惑.对于持久化的数据来说更要小心.其实在开始设计message的时候应该合理和小心的使用数据类型和字段类型,pb提供了不错的兼容性而无需我们而外coding,但不代表我们可以完全依赖它,总有些情况是无法满足的,所以在设计初期应该考虑到.</p>

<h3>应用场景</h3>

<ol>
<li>复杂分布式环境,良好的兼容性和扩展性,平台无关.</li>
<li>小数据通讯,存储,对于kb级一下的数据,性能较好,但不为大数据准备,如有需要请合理将大数据分片.</li>
</ol>


<h3>问题</h3>

<ol>
<li>小数据通讯</li>
<li>处于发展中,只使用必要功能,除非你深入研究原理</li>
<li>管理好messag</li>
</ol>


<hr />

<h2>总结</h2>

<p>设计总是要把问题规约到某几个核心问题上,放弃华而不实的功能点,放弃建造巴别塔.以核心问题为标准来衡量设计的必要性和设计的关注点.</p>

<h2>参考</h2>

<ul>
<li><a href="http://www.cppblog.com/true/archive/2009/09/11/95873.html">varint的一些编码说明</a></li>
<li><a href="https://developers.google.com/protocol-buffers/docs/encoding?hl=zh-CN">官方说明,注意关于负数的那段</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-gpb/?ca=drs-tp4608">很全面的介绍</a></li>
<li><a href="http://www.searchtb.com/2012/09/protocol-buffers.html">完全做到动态message,当然有代价,是否合理不作讨论</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[dalvik内存分配无碎片的思考]]></title>
    <link href="http://songjie-dong.github.com/blog/2012/09/23/shen-ru-li-jie-ji-suan-ji-malloc/"/>
    <updated>2012-09-23T16:56:00+08:00</updated>
    <id>http://songjie-dong.github.com/blog/2012/09/23/shen-ru-li-jie-ji-suan-ji-malloc</id>
    <content type="html"><![CDATA[<p>最近看dalvik的gc机制,发现没啥太多资料,但是注意到了dalvik并没有做内存整理,也就是compact阶段,传言内部有一些机制来避免碎片形成,很好奇,分析一下</p>

<h2>一些概念</h2>

<h3>动态内存分配器 dynamic memory allocator</h3>

<p>何为<strong>动态内存分配</strong>,大家知道,在有些时候我们并不能一开始就知道需要用到的内存,比如读取一班级的所有同学信息到一个数组,数组的大小取决于运行时以某种方式查询获知,于是我们需要在运行时分配内存.无论是在vm上跑的java还是在操作系统里跑的c,对于内存的使用都会包含一下的基本部分,栈,固定的分配好的区域,堆,栈里面的数据是操作系统或vm会处理分配和释放,堆(heap)则负责动态内存分配,java和c不同的是jvm使用的<strong>隐式分配器</strong>,而c则是<strong>显式分配器</strong>,区别就是一个有gc,new出来就可以,另一个则由我们自己显式malloc和free.</p>

<h3>碎片</h3>

<p>jvm的<strong>current mark and sweep</strong>收集器提供了可选的compact功能,即整理内存,或者形象点说就是把内存压实,把空的缝隙的给挤掉.这里的碎片指的是<strong>外部碎片</strong>.我们把内存看成一大块连续的内存空间,而且空间可以<strong>伸缩</strong>(<strong>sbrk</strong>),当我们需要使用内存的时候,则在这块空间中寻找合适的位置存放数据,假设我们每次都从heap的头位置开始寻找,一旦找到合适的闲置块就分配,free时则直接标记该块未使用这种方式,进程运行初期总是分配小块内存使用,于是在运行一段时候后,整个heap被分割成了很多的小块,此时如果突然开始出现大数据块的分配请求,则很可能无法找到合适的位置只能请求新的空间.(当然这是malloc极端简单的分配策略)</p>

<p><strong>内部碎片</strong>是相对于外部碎片而言的,讨论内部碎片往往意味着分配器采用了不同于刚刚的分配策略,以<strong>memcached</strong>为例,memcached的内存管理策略是将内存分为不同的classes,假设一个class总长度1m,然后将其等分为固定大小的chunk,比如等分成16份,则每个chunk为64k,一个chunk为最小的分配单元,memcached用<strong>O(1)</strong>(为什么可以做到O(1),用上述的简单内存分配策略能否做到呢?)的时间寻找最合适的chunk来存储数据,但是无论如何分配,每个chunk都很难被100%使用,这就产生了内部碎片.划分classes的方法可以很好的提高分配效率,但同时也需要一些<strong>启发式的策略</strong>来优化内存有效使用率.PS:由于memcached的内存分配很死板,如果内存已经被各种不同chunk大小的classes占满,class分布完成则无法改变,这等于是把启发式策略做了一半,现在貌似在改进了.</p>

<h2>经典</h2>

<ul>
<li>dlmalloc
doug lea大神的作品,参见<a href="http://gee.cs.oswego.edu/dl/html/malloc.html">A Memory Allocator</a>,此文讲的很全面,特别是对于何为优秀的内存分配器,提了八个点.里面的一些分配器实现的理念被后续沿用,算是必读文章之一,不过内容有些滞后,很多dlmalloc后续的更新并没有描述.</li>
<li>jemalloc
增加了对于多核的分配优化,将内存分成不同的Arena,避免部分场景分配时竞争带来的开销,jvm中同样有类似的概念TLAB(Thead local allocate buffer),对于小对象的分配直接在thread独占的区域分配.记得里面还提到了缓存作色的优化.</li>
<li>tcmalloc
类似jemalloc,有些测试结果表明性能更好,缺点是需要关注内存的有效使用率,分配速度和内存有效使用率是分配器设计时需要取舍的.PS:如果想研究分配器,可以读读代码,应该很不错.</li>
</ul>


<h2>分配器总结</h2>

<p><strong>多核,多线程</strong>的分配优化,<strong>缓存作色</strong>,内存有效使用率(使用划分固定大小chunk的机制会提高分配的效率,降低分配高性能实现的复杂度,但不可避免的会有内存有效使用率的问题,需要一些启发式的优化策略,具体取舍看场景,内存很宝贵则可以在分配速度上让步,二者难以兼得,相关知识建议直接看深入理解计算机相关章节,想挖坑的可以看论文),这些问题都是现代分配器高性能的关键词.</p>

<h2>题外话</h2>

<p>回过头来看jvm,为啥老有碎片呢&#8230;难道是为了顾及一次书写,到处执行，so内部实现的内存管理实现的通用内存分配来跨平台?问题很多哇,可时间不多~,后续研究，碎叫~</p>
]]></content>
  </entry>
  
</feed>
